% !TeX spellcheck = nl_NL
\documentclass{article}

\begin{document}
	\subsection{Pagina's genereren} 
	\subsubsection{Wat is het?}
	Als we pagina's gaan genereren, gaan we wijzigingen van het ERP doorduwen naar AEM. AEM gaat aan de hand van deze informatie noden aanmaken in onze JCR repository en per taalvariant een pagina voorzien. Eenmaal de pagina's aangemaakt zijn, kunnen ze via de corresponderende url worden opgehaald.
	\subsubsection{Hoe werkt het?}
	Om deze optie te voorzien moeten er enkele zaken gecodeerd worden in Java, met name de functionaliteit om via de SlingRepository de data weg te schrijven naar een node en de PageManager van AEM gebruiken om de pagina's aan te maken. Alsook moeten we een HTML template voorzien die we kunnen gebruiken om onze categorie weer te geven. Tijdens het genereren van de pagina kunnen we verwijzen naar deze template om een standaard look te geven aan de pagina. Eenmaal deze pagina er is kan het contentteam aan de slag om deze een persoonlijke touch te geven.
	\par
	Om een node aan te maken moeten we eerst een Session verkrijgen waarin we kunnen werken, dit kunnen we doen door de login methode op onze SlingRepository aan te roepen met onze credentials. JcrUtils is een voorziene klasse waarmee we noden kunnen aanmaken, het enige dat we nodig hebben is een pad waaronder we deze willen opslaan, het type dat we aan de node willen toekennen en onze reeds verkregen sessie. Als we de node hebben aangemaakt rest ons nog enkel over mappen van de velden naar onze noden, indien ons model velden bevat die een klasse op zich zijn, moeten we met geneste noden werken. Dit nesten is heeft geen beperkingen en kan zo diep als nodig zijn. Wanneer de velden zijn overgezet mogen we niet vergeten om de save methode van onze sessie aan te roepen zodat onze data gepersisteerd wordt.
	\par
	De volgende stap is een pagina voor ons model aanmaken, dit per taal waarin onze website beschikbaar is. Een pagina aanmaken gebeurt op een gelijkaardige manier als een node. We gebruiken de PageManager die de AEM api ons beschikbaar stelt. Omdat we zaken gaan persisteren moeten we ook hier werken met een sessie. Via de pageManager kunnen we onze root pagina van de website opvragen. De directe kinderen van deze pagina stellen de talen voor waarin onze site beschikbaar is. We itereren over deze lijst waarbij we per kind (lees taal) een pagina genereren. We maken deze pagina niet rechtstreeks onder de taalpagina aan maar voorzien een tussen pagina, bv. categoriëen. Wanneer we een categorie met id 14 hebben gaan we de pagina hiervoor opslaan onder <onze site>/nl/categorieen/14. Het pad dat we dan meegeven aan de create methode van de pageManager is het pad van de ouder waaronder we een pagina willen maken. Naast deze parameter geven we ook de pagina naam mee (in ons voorbeeld 14), de template (de locatie van de html die we gebruiken om onze pagina te tonen) en een modeltitel (bv. 'category'). Nu de pagina is aangemaakt kunnen we hiervan de node opvragen en kunnen we, conform aan vorige paragraaf, deze voorzien van properties. Het is aan te raden om deze properties te voorzien met een prefix om een duidelijk onderscheid te maken dus de properties die we zelf creëeren en diegene die door JCR aangemaakt zijn. Stel dat we een veld 'title' hebben die we wensen op te slaan, doen we dit onder '<custom-tag>:title'.
    \par
    In vorige paragraaf gebruiken we een template om onze categorie te tonen, deze gaan we zelf voorzien. Het is best om hier gebruik te maken van het componenten systeem waarvoor AEM gekend is. In plaats van een specifieke html te coderen gaan we deze opslitsen in herbruikbare componenten. Elke component is samengesteld uit een HTML bestand, een (optionele maar aan te raden) Java klasse en drie XML bestanden. De HTML spreekt voor zich, hier definiëren we de structuur en de styling. De Java klasse werkt als placeholder voor de velden van onze paginanode, als we een property '<custom-tag>:title' hebben voorzien we hiervoor een String en annoteren die met @Inject en @Named('<custom-tag>:title'). Nu is het mogelijk om via Sightly onze klasse te koppelen aan onze html door het attribuut 'data-sly-use.model="<package naam>.<klasse naam>"' in een html tag toe te voegen. Het stuk na 'data-sly-use.' definiëert hoe we deze gaan aanspreken, in ons voorbeeld hebben we deze model genoemd. Nu kunnen we binnen de html tag onze klasse gebruiken via volgende syntax: \${model.title}, gegeven er een getTitle() methode op onze Java klasse staat.
    \par
    De xml files....
    \par
    Eenmaal we de nodige componenten hebben aangemaakt kunnen deze gebruikt worden om een template te voorzien. We kunnen de componenten rechtstreeks aan onze template toevoegen of een tussen component voorzien die de kleinere componenten combineert. Dit kan handig zijn wanneer de zelfde combinatie van componenten meermaals gebruikt wordt, ook de css en js bestanden kunnen we in deze wrapper inladen zodat we ons daarover geen zorgen moeten maken wanneer we template samenstellen. Eenmaal de template af is kan deze gebruikt worden om automatisch pagina's te genereren of om via de author handmatig een pagina toe te voegen.
	\subsubsection{De voordelen}
    Het voordeel van deze manier van werken is dat wanneer een gebruiker de pagina opgevraagt, deze reeds voorzien is van data waardoor er geen repositories worden aangesproken. Uiteraard is dit wel het geval als we componenten toevoegen die dynamische content voorzien maar de properties die we aan onze node hebben toegevoegd zijn reeds aanwezig. Een bijkomend voordeel is dat, door het feit dat er een pagina aangemaakt is, we deze via de author kunnen bewerken. We maken weliswaar een pagina via een standaard template maar hier hoeft het niet bij te blijven. We kunnen deze via de author gaan editeren en van specifieke content zoals bv. een achtergrond afbeelding, een paragraaf met extra informatie of een uitgelicht product. Pagina's genereren is de enigste manier van werken die dit mogelijk maakt.
	\subsubsection{De nadelen}
    Het grote nadeel van deze methode is dat dit een vrij intensieve operatie is en het genereren zelden beperkt is tot één enkele pagina, wanneer een site drie talen heeft zullen er telkens drie pagina's aangemaakt worden. Dit wordt nog eens geëxpandeerd indien men via een blueprint werkt. Stel dat we een .com site hebben met drie talen, een .be site met drie talen en een .nl site met twee talen. Dit betekent dat per categorie we zeven pagina's moeten voorzien. Voor een model waar relatief weinig wijzigingen aan gebeurt is dit doenbaar, zoals ons categorie voorbeeld. Maar als we dit willen doortrekken naar producten, waar er mogelijks duizenden per dag wijzigen, is dit niet houdbaar. Onze author zou continue belast worden met het genereren van pagina's en eventueel bezwijken onder een de load. Een tweede author plaatsen is zelden een optie omdat dit het gelicentieerde deel is van AEM, een tweede author betekent een tweede licentie.
\end{document}