% !TeX spellcheck = nl_NL
\documentclass{article}

\begin{document}
	\subsection{Server Side Includes} 
	\subsubsection{Wat is het?}
	SSI is een scriptingstechniek die de mogelijkheid biedt om data in een bestaande HTML te injecteren. Deze injectie kan een effectief bestand betreffen maar kan evengoed een functie zijn, bv. de huidige datum ophalen. Vlak voor het versturen van de HTML zal de webserver alle SSI commando's opsporen en omzetten naar standaard HTML-tags. De bestandtypes die men via SSI ophaalt kan verschillende vormen aannemen waaronder JSON (bv. het resultaat van een REST call) en HTML (bv. een footer die ge\"injecteerd wordt). In het geval van JSON zou men het resultaat kunnen gebruiken voor een Javascript functie, bij HTML kan deze rechtstreeks worden afgebeeld. Best practice is om de SSI commando's in commentaar te zetten zodat deze verdwijnen wanneer de webserver SSI niet ondersteunt.
	\subsubsection{Waarom SSI?}
    Binnen AEM kunnen we templates bouwen aan de hand van bestaande componenten, een goed voorbeeld is een template die een navigatie bevat, we willen immers op de meeste pagina's onze navigatie tonen. Wanneer deze template gebruikt wordt genereren we een pagina met daarop onze navigatie en een gespecifieerde inhoud. Als een gebruiker deze pagina ophaalt passeert dit verzoek de dispatcher, als de pagina nog in zijn cache zit kan deze onmiddelijk worden weergegeven. Indien dit niet het geval is moet deze opgehaald worden bij een publisher, vervolgens wordt deze op de dispatcher gecached en doorgestuurd naar de gebruiker. Dit betekent dat de hele pagina, inclusief navigatie, gecached wordt op de dispatcher. 
    \par
    Zolang de navigatie ongewijzigd blijft brengt dit geen problemen teweeg. Stel nu dat er een nieuwe categorie aangemaakt wordt en deze zichtbaar moet worden in de navigatie. We hebben in het vorige hoofdstuk gezien hoe we categorie pagina's kunnen maken en hoe de navigatie deze oppikt. Het enige obstakel om deze live te krijgen is de dispatcher die de navigatie op elke pagina apart heeft gecached. We kunnen wachten tot deze verloopt maar dit tijdstip is voor elke pagina anders. Langzaam aan zullen de gecachte pagina's verlopen waardoor deze opnieuw moeten worden opgehaald (met de nieuwe navigatie). Tijdens deze overgangsperiode zal de navigatie op onze website inconsistent zijn, sommige pagina's hebben de oude (gecachte) versie en andere hebben reeds de nieuwe.
    \par
    Sommige lezers zullen nu denken: \"We kunnen toch de hele cache tegelijk invalideren? Dan moet de dispatcher wel de nieuwe versie ophalen. Deze gedachtegang is correct maar heeft \'e\'en groot nadeel: de publisher moet dan mogelijk enkele honderden pagina's tegelijk genereren wat kan leiden tot een crash. Buiten piekuren en met een beperkt aantal pagina's kan deze methode haalbaar zijn, voor een internationale enterprise applicatie is dit niet realistisch en moet er een andere oplossing gezocht worden.
    \par
    Deze oplossing kan men bekomen met het gebruik van SSI, in plaats van onze template rechtstreeks van de navigatie component te voorzien gebruiken we SSI om deze toe te voegen. Als men nu een pagina opvraagt zal de dispatcher deze laten genereren door de publisher maar deze zal de SSI-tag nog niet resolven. Deze tag wordt mee gecached, met de rest van de pagina, en zal pas op het laatste moment ervoor zorgen dat de navigatie wordt ge\"injecteerd. Wanneer deze injecte moet gebeuren zal de dispatcher de navigatie opvragen bij de publisher en deze cachen. Alle pagina's gaan nu de gecachte versie van onze navigatie injecteren en als deze wijzigt volstaat het om enkel de cache van de navigatie te invalideren.
    \par
    Het is belangrijk om te beseffen dat SSI enkel op de dispatcher zal worden uitgevoerd wat geen probleem vormt in productie, elk request passeert hier. Voor het contentteam vormt dit wel een probleem, zij werken op de author en aangezien deze de injectie niet gaat uitvoeren zullen zij de navigatie niet te zien krijgen tijdens het editeren van pagina's. Een mogelijkheid is om overal waar men SSI wil gebruiken deze tag in een IF-statement te incapsuleren, indien de pagina niet vanop de author wordt opgevraagd gebruikt men de tag, anders injecteert men de data rechtstreeks.
	\subsubsection{De nadelen}
    E\'en nadeel hebben we reeds gezien, om het editeren van pagina's aangenaam te houden moeten we overal waar we SSI willen gebruiken extra statements voorzien om hetzelfde resultaat op de author te bekomen. Bij uitbundig gebruik kan dit leiden tot onoverzichtelijke code die moeilijk te onderhouden is.
    \par
    Een ander nadeel is dat de commando's worden uitgevoerd vlak voor de webserver de HTML verstuurd. Dit heeft als gevolg dat de gebruiker moet wachten tot alle commando's zijn uitgevoerd voor hij de pagina te zien krijgt. Als we een gecachte HTML injecteren zal deze wachttijd nihil zijn. Wanneer men meerdere REST calls wil doen kan, afhankelijk van de duur van deze calls, de wachttijd oplopen. In dit geval moet men de overweging maken om over te stappen op Javascript voor zaken die niet onmiddellijk vereist zijn. Denk hierbij aan de waarden van een dropdown, de gebruiker gaat niet doorhebben dat deze een seconde later aanwezig waren. 
\end{document}