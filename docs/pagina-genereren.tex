% !TeX spellcheck = nl_NL
\documentclass{article}

\begin{document}
	\subsection{Pagina's genereren} 
	\subsubsection{Wat is het?}
	Als we pagina's gaan genereren, gaan we wijzigingen van het ERP doorduwen naar AEM. AEM gaat aan de hand van deze informatie noden aanmaken in onze JCR repository en per taalvariant een pagina voorzien. Eenmaal de pagina's aangemaakt zijn, kunnen ze via de corresponderende url worden opgehaald.
	\subsubsection{Hoe werkt het?}
	Om deze optie te voorzien moeten er enkele zaken gecodeerd worden in Java, met name de functionaliteit om via de SlingRepository de data weg te schrijven naar een node en de PageManager van AEM gebruiken om de pagina's aan te maken. Alsook moeten we een HTML template voorzien die we kunnen gebruiken om onze categorie weer te geven. Tijdens het genereren van de pagina kunnen we verwijzen naar deze template om een standaard look te geven aan de pagina. Eenmaal deze pagina er is kan het contentteam aan de slag om deze een persoonlijke touch te geven.
	\par
	Om een node aan te maken moeten we eerst een Session verkrijgen waarin we kunnen werken, dit kunnen we doen door de login methode op onze SlingRepository aan te roepen met onze credentials. JcrUtils is een voorziene klasse waarmee we noden kunnen aanmaken, het enige dat we nodig hebben is een pad waaronder we deze willen opslaan, het type dat we aan de node willen toekennen en onze reeds verkregen sessie. Als we de node hebben aangemaakt rest ons nog enkel over mappen van de velden naar onze noden, indien ons model velden bevat die een klasse op zich zijn, moeten we met geneste noden werken. Dit nesten is heeft geen beperkingen en kan zo diep als nodig zijn. Wanneer de velden zijn overgezet mogen we niet vergeten om de save methode van onze sessie aan te roepen zodat onze data gepersisteerd wordt.
	\par
	De volgende stap is een pagina voor ons model aanmaken, dit per taal waarin onze website beschikbaar is. Een pagina aanmaken gebeurt op een gelijkaardige manier als een node aanmaken. We gebruiken de PageManager die de AEM api ons beschikbaar stelt. Omdat we zaken gaan persisteren moeten we ook hier werken met een sessie. Via de pageManager kunnen we onze root pagina van de website opvragen. De directe kinderen van deze pagina stellen de talen voor waarin onze site beschikbaar is. We itereren over deze lijst waarbij we per kind (lees taal) een pagina genereren. We maken deze pagina niet rechtstreeks onder de taalpagina aan maar voorzien een tussen pagina, bv. categoriëen. Wanneer we een categorie met id 14 hebben gaan we de pagina hiervoor opslaan onder <onze site>/nl/categorieen/14. Het pad dat we dan meegeven aan de create methode van de pageManager is het pad naar de ouder van de pagina die we aan het maken zijn. Naast deze parameter geven we ook de pagina naam mee (in ons voorbeeld 14), de template (de locatie van de html die we gebruiken om onze pagina te tonen) en een modeltitel (bv. 'category'). Nu de pagina is aangemaakt kunnen we hiervan de node opvragen en kunnen we, conform aan vorige paragraaf, deze voorzien van properties. Het is aan te raden om deze properties te voorzien met een prefix om een duidelijk onderscheid te maken dus de properties die we zelf gaan gebruiken en die voor JCR. Stel dat we een veld 'title' hebben die we wensen op te slaan, doen we dit onder '<custom-tag>:title'.
    \par
    In vorige paragraaf gebruiken we een template om onze categorie te tonen, deze gaan we zelf voorzien. Het is best om hier gebruik te maken van het componenten systeem waarvoor AEM gekend is. In plaats van een specifieke html te coderen gaan we deze opslitsen in herbruikbare componenten. Elke component is samengesteld uit een HTML bestand, een (optionele maar aan te raden) Java klasse en drie XML bestanden. De HTML spreekt voor zich, hier definiëren we de structuur en de styling. De Java klasse werkt als placeholder voor de velden van onze paginanode, als we een property '<custom-tag>:title' hebben voorzien we hiervoor een String en annoteren die met @Inject en @Named('<custom-tag>:title'). Nu is het mogelijk om via Sightly onze klasse te koppelen aan onze html door het attribuut 'data-sly-use.model="<package naam>.<klasse naam>"' in een html tag toe te voegen. Het stuk na 'data-sly-use.' definiëert hoe we deze gaan aanspreken, in ons voorbeeld hebben we deze model genoemd. Nu kunnen we binnen de html tag onze klasse gebruiken via volgende syntax: \${model.title}, gegeven er een getTitle() methode op onze Java klasse staat.
    \par
    De xml files....
	\subsubsection{De voordelen}
    
	\subsubsection{De nadelen}
\end{document}